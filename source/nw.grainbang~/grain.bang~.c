/*** grain.bang~.c**** MSP object** sends out a single grains when it receives a bang ** ** 2001/07/18 started by Nathan Wolek** */#include "ext.h"		// required for all MAX external objects#include "z_dsp.h"		// required for all MSP external objects#include "buffer.h"		// required to deal with buffer object#include <string.h>//#define DEBUG			//enable debugging messages#define LAST_YEAR		"2001"				// last date code was changed#define LAST_MONTH		"09"#define LAST_DATE		"04"#define OBJECT_NAME		"grain.bang~"		// name of the object/* for the assist method */#define ASSIST_INLET	1#define ASSIST_OUTLET	2/* for the grain stage */#define NEW_GRAIN		2#define FINISH_GRAIN	1#define	NO_GRAIN		0/* for direction flag */#define FORWARD_GRAINS		0#define REVERSE_GRAINS		1/* for interpolation flag */#define INTERP_OFF			0#define INTERP_ON			1void *this_class;		// required global pointing to this classtypedef struct _grainbang{	t_pxobject x_obj;	// sound buffer info	t_symbol *snd_sym;	t_buffer *snd_buf_ptr;	double snd_last_out;	long snd_buf_length;	short snd_interp;	// window buffer info	t_symbol *win_sym;	t_buffer *win_buf_ptr;	double win_last_out;	long win_buf_length;	short win_interp;	// current grain info	double grain_pos_start;	// in samples	double grain_length;	// in milliseconds	double grain_pitch;		// as multiplier	double grain_sound_length;	// in milliseconds	double win_step_size;	// in samples	double snd_step_size;	// in samples	double curr_win_pos;	// in samples	double curr_snd_pos;	// in samples	short grain_direction;	// forward or reverse	// defered grain info at control rate	double next_grain_pos_start;	// in milliseconds	double next_grain_length;		// in milliseconds	double next_grain_pitch;		// as multiplier	short next_grain_direction;		// forward or reverse	// signal or control grain info	short grain_pos_start_connected;	short grain_length_connected;	short grain_pitch_connected;	// grain tracking info	short grain_stage;	long curr_grain_samp;	double output_sr;	double output_1oversr;} t_grainbang;void *grainbang_new(t_symbol *snd, t_symbol *win);t_int *grainbang_perform(t_int *w);t_int *grainbang_perform0(t_int *w);void grainbang_dsp(t_grainbang *x, t_signal **sp, short *count);void grainbang_setsnd(t_grainbang *x, t_symbol *s);void grainbang_setwin(t_grainbang *x, t_symbol *s);void grainbang_float(t_grainbang *x, double f);void grainbang_int(t_grainbang *x, long l);void grainbang_bang(t_grainbang *x);void grainbang_sndInterp(t_grainbang *x, long l);void grainbang_winInterp(t_grainbang *x, long l);void grainbang_reverse(t_grainbang *x, long l);void grainbang_assist(t_grainbang *x, t_object *b, long msg, long arg, char *s);float allpassInterp(float *in_array, float index, float last_out, long buf_length);t_symbol *ps_buffer;/********************************************************************************void main(void)inputs:			nothingdescription:	called the first time the object is used in MAX environment; 		defines inlets, outlets and accepted messagesreturns:		nothing********************************************************************************/void main(void){	setup(&this_class, grainbang_new, (method)dsp_free, (short)sizeof(t_grainbang),			0L, A_SYM, A_SYM, 0);	addmess((method)grainbang_dsp, "dsp", A_CANT, 0);		/* bind method "grainbang_setsnd" to the 'setSound' message */	addmess((method)grainbang_setsnd, "setSound", A_SYM, 0);		/* bind method "grainbang_setwin" to the 'setWin' message */	addmess((method)grainbang_setwin, "setWin", A_SYM, 0);		/* bind method "grainbang_float" to incoming floats */	addfloat((method)grainbang_float);		/* bind method "grainbang_int" to incoming ints */	addint((method)grainbang_int);		/* bind method "grainbang_bang" to incoming bangs */	addbang((method)grainbang_bang);		/* bind method "grainbang_reverse" to the direction message */	addmess((method)grainbang_reverse, "reverse", A_LONG, 0);		/* bind method "grainbang_sndInterp" to the sndInterp message */	addmess((method)grainbang_sndInterp, "sndInterp", A_LONG, 0);		/* bind method "grainbang_winInterp" to the winInterp message */	addmess((method)grainbang_winInterp, "winInterp", A_LONG, 0);		/* bind method "grainbang_assist" to the assistance message */	addmess((method)grainbang_assist, "assist", A_CANT, 0);		dsp_initclass();		/* needed for 'buffer~' work, checks for validity of buffer specified */	ps_buffer = gensym("buffer~");		#ifndef DEBUG		post("%s object by Nathan Wolek", OBJECT_NAME);		post("Last updated %s.%s.%s - www.nathanwolek.com", LAST_YEAR, LAST_MONTH, 					LAST_DATE);	#endif /* DEBUG */}/********************************************************************************void *grainbang_new(double initial_pos)inputs:			*snd		-- name of buffer holding sound				*win		-- name of buffer holding windowdescription:	called for each new instance of object in the MAX environment;		defines inlets and outlets; sets variables and buffersreturns:		nothing********************************************************************************/void *grainbang_new(t_symbol *snd, t_symbol *win){	t_grainbang *x = (t_grainbang *)newobject(this_class);	dsp_setup((t_pxobject *)x, 4);					// four inlets	outlet_new((t_pxobject *)x, "signal");			// one outlet		/* set buffer names */	x->snd_sym = snd;	x->win_sym = win;		/* setup variables */	x->grain_pos_start = x->next_grain_pos_start = 0.0;	x->grain_length = x->next_grain_length = 50.0;	x->grain_pitch = x->next_grain_pitch = 1.0;	x->grain_stage = NO_GRAIN;	x->win_step_size = x->snd_step_size = 0.0;	x->curr_win_pos = x->curr_snd_pos = 0.0;		/* set flags to defaults */	x->snd_interp = INTERP_ON;	x->win_interp = INTERP_OFF;	x->grain_direction = x->next_grain_direction = FORWARD_GRAINS;		x->x_obj.z_misc = Z_NO_INPLACE;		/* return a pointer to the new object */	return (x);}/********************************************************************************void grainbang_dsp(t_cpPan *x, t_signal **sp, short *count)inputs:			x		-- pointer to this object				sp		-- array of pointers to input & output signals				count	-- array of shorts detailing number of signals attached					to each inletdescription:	called when DSP call chain is built; adds object to signal flowreturns:		nothing********************************************************************************/void grainbang_dsp(t_grainbang *x, t_signal **sp, short *count){	/* set buffers */	grainbang_setsnd(x, x->snd_sym);	grainbang_setwin(x, x->win_sym);		/* test inlet 2 and 3 for signal data */	x->grain_pos_start_connected = count[1];	x->grain_length_connected = count[2];	x->grain_pitch_connected = count[3];		x->output_sr = sp[4]->s_sr;	x->output_1oversr = 1.0 / x->output_sr;		if (!count[4]) {	// nothing computed		dsp_add(grainbang_perform0, 2, sp[4]->s_vec, sp[4]->s_n);		#ifdef DEBUG			post("%s: no output computed", OBJECT_NAME);		#endif /* DEBUG */	} else {		// output computed		dsp_add(grainbang_perform, 6, x, sp[1]->s_vec, sp[2]->s_vec, sp[3]->s_vec,			sp[4]->s_vec, sp[4]->s_n);		#ifdef DEBUG			post("%s: output is being computed", OBJECT_NAME);		#endif /* DEBUG */	}	}/********************************************************************************t_int *grainbang_perform(t_int *w)inputs:			w		-- array of signal vectors specified in "grainbang_dsp"description:	called at interrupt level to compute object's output; used when		outlets are connected; tests inlet 2 3 & 4 to use either control or audio		rate datareturns:		pointer to the next ********************************************************************************/t_int *grainbang_perform(t_int *w){	t_grainbang *x = (t_grainbang *)(w[1]);	float in_pos_start = *(float *)(w[2]);	float in_length = *(float *)(w[3]);	float in_pitch_mult = *(float *)(w[4]);	t_float *out = (t_float *)(w[5]);	int vec_size = (int)(w[6]);	t_buffer *s_ptr = x->snd_buf_ptr;	t_buffer *w_ptr = x->win_buf_ptr;	float *tab_s, *tab_w;	double s_step_size, w_step_size;	float  snd_out, win_out, last_s, last_w;	double temp, index_s, index_w;	long size_s, size_w;	short interp_s, interp_w, g_direction;		vec_size += 1;		//increase by one for pre-decrement	--out;				//decrease by one for pre-increment		/* check to make sure buffers are loaded with proper file types*/	if (x->x_obj.z_disabled)						// object is enabled		goto out;	if (!s_ptr || !w_ptr)									// buffer names are defined		goto zero;	if (!s_ptr->b_valid || !w_ptr->b_valid)					// files are loaded		goto zero;	if (s_ptr->b_nchans != 1 || w_ptr->b_nchans != 1)		// files are mono		goto zero;		if (x->grain_stage == NEW_GRAIN) {		x->grain_direction = x->next_grain_direction;				/* test if variables should be at audio or control rate */		if (x->grain_length_connected) { // if length is at audio rate			x->grain_length = in_length;		} else { // if length is at control rate			x->grain_length = x->next_grain_length;		}				if (x->grain_pitch_connected) { // if pitch multiplier is at audio rate			x->grain_pitch = in_pitch_mult;		} else { // if pitch multiplier at control rate			x->grain_pitch = x->next_grain_pitch;		}				// compute amount of sound file for grain		x->grain_sound_length = x->grain_length * x->grain_pitch;				// compute window buffer step size per vector sample 		x->win_step_size = x->win_buf_length / (x->grain_length * x->output_sr * 0.001);		// compute sound buffer step size per vector sample		x->snd_step_size = x->grain_pitch * s_ptr->b_sr * x->output_1oversr;				if (x->grain_pos_start_connected) { // if position is at audio rate			if (x->grain_direction == FORWARD_GRAINS) {	// if forward...				x->grain_pos_start = in_pos_start * s_ptr->b_msr;				x->curr_snd_pos = x->grain_pos_start - x->snd_step_size;			} else {	// if reverse...				x->grain_pos_start = (in_pos_start + x->grain_sound_length) * s_ptr->b_msr;				x->curr_snd_pos = x->grain_pos_start + x->snd_step_size;			}		} else { // if position is at control rate			if (x->grain_direction == FORWARD_GRAINS) {	// if forward...				x->grain_pos_start = x->next_grain_pos_start * s_ptr->b_msr;				x->curr_snd_pos = x->grain_pos_start - x->snd_step_size;			} else {	// if reverse...				x->grain_pos_start = (x->next_grain_pos_start + x->grain_sound_length) * s_ptr->b_msr;				x->curr_snd_pos = x->grain_pos_start + x->snd_step_size;			}		}				x->curr_win_pos = 0.0 - x->win_step_size;		// reset history		x->snd_last_out = x->win_last_out = 0.0;				/* move to next stage */		x->grain_stage = FINISH_GRAIN;				#ifdef DEBUG			post("%s: beginning of grain", OBJECT_NAME);			post("%s: win step size = %f samps", OBJECT_NAME, x->win_step_size);			post("%s: snd step size = %f samps", OBJECT_NAME, x->snd_step_size);		#endif /* DEBUG */					}		if (x->grain_stage == FINISH_GRAIN) {				// get option settings		interp_s = x->snd_interp;		interp_w = x->win_interp;		g_direction = x->grain_direction;		// get pointer info		s_step_size = x->snd_step_size;		w_step_size = x->win_step_size;		index_s = x->curr_snd_pos;		index_w = x->curr_win_pos;		// get buffer info		tab_s = s_ptr->b_samples;		tab_w = w_ptr->b_samples;		size_s = x->snd_buf_length;		size_w = x->win_buf_length;		last_s = x->snd_last_out;		last_w = x->win_last_out;				while (--vec_size) {						/* advance index of sound buffer */			if (g_direction == FORWARD_GRAINS) {	// if forward...				index_s += s_step_size;		// add to sound index			} else {	// if reverse...				index_s -= s_step_size;		// subtract from sound index			}			index_w += w_step_size;			// add a step						/* check bounds of sound index; wraps if not within bounds */			while (index_s < 0.0)				index_s += size_s;			while (index_s >= size_s)				index_s -= size_s;						/* check bounds of window index */			if (index_w > size_w) {				x->grain_stage = NO_GRAIN;				*++out = 0.0;				#ifdef DEBUG					post("%s: end of grain", OBJECT_NAME);				#endif /* DEBUG */				break;			}						if (interp_w == INTERP_ON) {				/* perform allpass interpolation on window buffer output */				win_out = allpassInterp(tab_w, (float)index_w, last_w, size_w);			} else { // if INTERP_OFF //				/* interpolation sounds better than following, but uses more CPU */				win_out = tab_w[(long)index_w];			}						if (interp_s == INTERP_OFF) {				/* interpolation sounds better than following, but uses more CPU */				snd_out = tab_s[(long)index_s];			} else { // if INTERP_ON //				/* perform allpass interpolation on sound buffer output */				snd_out = allpassInterp(tab_s, (float)index_s, last_s, size_s);			}						/* multiply snd_out by win_value */			*++out = snd_out * win_out;						/* update last output variables */			last_s = snd_out;			last_w = win_out;		}				/* update last output variables */		x->snd_last_out = last_s;		x->win_last_out = last_w;		x->curr_snd_pos = index_s;		x->curr_win_pos = index_w;			}		if (x->grain_stage == NO_GRAIN) {		while (--vec_size) *++out = 0.0;	}	return (w + 7);zero:		while (--vec_size) *++out = 0.0;out:		return (w + 7);}	/********************************************************************************t_int *grainbang_perform0(t_int *w)inputs:			w		-- array of signal vectors specified in "grainbang_dsp"description:	called at interrupt level to compute object's output; used when		nothing is connected to output; saves CPU cyclesreturns:		pointer to the next ********************************************************************************/t_int *grainbang_perform0(t_int *w){	t_float *out = (t_float *)(w[1]);	int vec_size = (int)(w[2]);	vec_size += 1;		//increase by one for pre-decrement	--out;				//decrease by one for pre-increment	while (--vec_size >= 0) {		*++out = 0.;	}	return (w + 3);}/********************************************************************************void grainbang_setsnd(t_index *x, t_symbol *s)inputs:			x		-- pointer to this object				s		-- name of buffer to linkdescription:	links buffer holding the grain sound source returns:		nothing********************************************************************************/void grainbang_setsnd(t_grainbang *x, t_symbol *s){	t_buffer *b;		x->snd_sym = s;	if ((b = (t_buffer *)(s->s_thing)) && ob_sym(b) == ps_buffer) {		if (b->b_nchans != 1) {			error("%s: buffer~ > %s < must be mono", OBJECT_NAME, s->s_name);		} else {			x->snd_buf_ptr = b;			x->snd_buf_length = b->b_frames;			x->snd_last_out = 0.0;						#ifdef DEBUG				post("%s: sound set to buffer~ > %s <", OBJECT_NAME, s->s_name);			#endif /* DEBUG */		}	} else {		error("%s: no buffer~ * %s * found", OBJECT_NAME, s->s_name);		x->snd_buf_ptr = 0;	}}/********************************************************************************void grainbang_setwin(t_grainbang *x, t_symbol *s)inputs:			x		-- pointer to this object				s		-- name of buffer to linkdescription:	links buffer holding the grain window returns:		nothing********************************************************************************/void grainbang_setwin(t_grainbang *x, t_symbol *s){	t_buffer *b;		x->win_sym = s;	if ((b = (t_buffer *)(s->s_thing)) && ob_sym(b) == ps_buffer) {		if (b->b_nchans != 1) {			error("%s: buffer~ > %s < must be mono", OBJECT_NAME, s->s_name);		} else {			x->win_buf_ptr = b;			x->win_buf_length = b->b_frames;			x->win_last_out = 0.0;						#ifdef DEBUG				post("%s: window set to buffer~ > %s <", OBJECT_NAME, s->s_name);			#endif		}	} else {		error("%s: no buffer~ > %s < found", OBJECT_NAME, s->s_name);		x->win_buf_ptr = 0;	}}/********************************************************************************void grainbang_float(t_grainbang *x, double f)inputs:			x		-- pointer to our object				f		-- value of float inputdescription:	handles floats sent to inlets; inlet 2 sets "next_grain_pos_start" 		variable; inlet 3 sets "next_grain_length" variable; inlet 4 sets 		"next_grain_pitch" variable; left inlet generates error message in max 		windowreturns:		nothing********************************************************************************/void grainbang_float(t_grainbang *x, double f){	if (x->x_obj.z_in == 1) // if inlet 2	{		x->next_grain_pos_start = f;	}	else if (x->x_obj.z_in == 2) // if inlet 3	{		if (f != 0.0) {			x->next_grain_length = f;		} else {			post("%s: grain length must not equal zero", OBJECT_NAME);		}	}	else if (x->x_obj.z_in == 3) // if inlet 4	{		x->next_grain_pitch = f;	}	else if (x->x_obj.z_in == 0)	{		post("%s: left inlet does not accept floats", OBJECT_NAME);	}}/********************************************************************************void grainbang_int(t_grainbang *x, long l)inputs:			x		-- pointer to our object				l		-- value of int inputdescription:	handles ints sent to inlets; inlet 2 sets "next_grain_pos_start" 		variable; inlet 3 sets "next_grain_length" variable; inlet 4 sets 		"next_grain_pitch" variable; left inlet generates error message in max 		windowreturns:		nothing********************************************************************************/void grainbang_int(t_grainbang *x, long l){	if (x->x_obj.z_in == 1) // if inlet 2	{		x->next_grain_pos_start = (double) l;	}	else if (x->x_obj.z_in == 2) // if inlet 3	{		if (l != 0) {			x->next_grain_length = (double) l;		} else {			post("%s: grain length must not equal zero", OBJECT_NAME);		}	}	else if (x->x_obj.z_in == 3) // if inlet 4	{		x->next_grain_pitch = (double) l;	}	else if (x->x_obj.z_in == 0)	{		post("%s: left inlet does not accept floats", OBJECT_NAME);	}}/********************************************************************************void grainbang_bang(t_grainbang *x)inputs:			x		-- pointer to our objectdescription:	handles bangs sent to inlets; inlet 1 creates a grain; all others	post an error to the max windowreturns:		nothing********************************************************************************/void grainbang_bang(t_grainbang *x){	if (x->x_obj.z_in == 0) // if inlet 1	{		if (x->grain_stage == NO_GRAIN) {			x->grain_stage = NEW_GRAIN;		}	}	else // all other inlets	{		post("%s: that inlet does not accept bangs", OBJECT_NAME);	}}/********************************************************************************void grainbang_sndInterp(t_grainbang *x, long l)inputs:			x		-- pointer to our object				l		-- flag valuedescription:	method called when "sndInterp" message is received; allows user 		to define whether interpolation is used in pulling values from the sound		buffer; default is onreturns:		nothing********************************************************************************/void grainbang_sndInterp(t_grainbang *x, long l){	if (l == INTERP_OFF) {		x->snd_interp = INTERP_OFF;		#ifdef DEBUG			post("%s: sndInterp is set to off", OBJECT_NAME);		#endif // DEBUG //	} else if (l == INTERP_ON) {		x->snd_interp = INTERP_ON;		#ifdef DEBUG			post("%s: sndInterp is set to on", OBJECT_NAME);		#endif // DEBUG //	} else {		error("%s: sndInterp message was not understood", OBJECT_NAME);	}}/********************************************************************************void grainbang_winInterp(t_grainbang *x, long l)inputs:			x		-- pointer to our object				l		-- flag valuedescription:	method called when "winInterp" message is received; allows user 		to define whether interpolation is used in pulling values from the window		buffer; default is offreturns:		nothing********************************************************************************/void grainbang_winInterp(t_grainbang *x, long l){	if (l == INTERP_OFF) {		x->win_interp = INTERP_OFF;		#ifdef DEBUG			post("%s: winInterp is set to off", OBJECT_NAME);		#endif // DEBUG //	} else if (l == INTERP_ON) {		x->win_interp = INTERP_ON;		#ifdef DEBUG			post("%s: winInterp is set to on", OBJECT_NAME);		#endif // DEBUG //	} else {		error("%s: winInterp was not understood", OBJECT_NAME);	}}/********************************************************************************void grainbang_reverse(t_grainbang *x, long l)inputs:			x		-- pointer to our object				l		-- flag valuedescription:	method called when "reverse" message is received; allows user 		to define whether sound is played forward or reverse; default is forwardreturns:		nothing********************************************************************************/void grainbang_reverse(t_grainbang *x, long l){	if (l == REVERSE_GRAINS) {		x->next_grain_direction = REVERSE_GRAINS;		#ifdef DEBUG			post("%s: reverse is set to on", OBJECT_NAME);		#endif // DEBUG //	} else if (l == FORWARD_GRAINS) {		x->next_grain_direction = FORWARD_GRAINS;		#ifdef DEBUG			post("%s: reverse is set to off", OBJECT_NAME);		#endif // DEBUG //	} else {		error("%s: reverse was not understood", OBJECT_NAME);	}	}/********************************************************************************void grainbang_assist(t_grainbang *x, t_object *b, long msg, long arg, char *s)inputs:			x		-- pointer to our object				b		--				msg		--				arg		--				s		--description:	method called when "assist" message is received; allows inlets 		and outlets to display assist messages as the mouse passes over themreturns:		nothing********************************************************************************/void grainbang_assist(t_grainbang *x, t_object *b, long msg, long arg, char *s){	if (msg==ASSIST_INLET) {		switch (arg) {			case 0:				strcpy(s, "(bang) output a grain");				break;			case 1:				strcpy(s, "(signal/float) sound begin, in milliseconds");				break;			case 2:				strcpy(s, "(signal/float) grain length, in milliseconds");				break;			case 3:				strcpy(s, "(signal/float) grain pitch multiplier, 1.0 = unchanged");				break;		}	} else if (msg==ASSIST_OUTLET) {		switch (arg) {			case 0:				strcpy(s, "(signal) grain output");				break;		}	}		#ifdef DEBUG		post("%s: assist message displayed", OBJECT_NAME);	#endif /* DEBUG */}/********************************************************************************float allpassInterp(float *in_array, float index, float last_out, long buf_length)inputs:			*in_array -- name of array of input values				index -- floating point index value to interpolate				last_out -- value of last interpolated outputdescription:	performs allpass interpolation on an input array and returns the	results to a location specified by a pointer; implements filter as specified	in Dattorro 2: J. Audio Eng. Soc., Vol 45, No 10, 1997 Octoberreturns:		interpolated output********************************************************************************/float allpassInterp(float *in_array, float index, float last_out, long buf_length){	// index = i.frac	long index_i = (long)index;					// i	long index_iP1 = index_i + 1;				// i + 1	float index_frac = index - (float)index_i;	// frac	float out;		// make sure that index_iP1 is not out of range	while (index_iP1 >= buf_length) index_iP1 -= buf_length;		// formula as on bottom of page 765 of above Dattorro article	out = in_array[index_i] + index_frac * (in_array[index_iP1] - last_out);		return out;}